require 'eventmachine'
require "steno"
require "steno/core_ext"
require 'json'
require "set"

require_relative "./conup/tx_dep_monitor"
require_relative "./conup/tx_event_type"
require_relative "./conup/client"
require_relative "./conup/tx_lifecycle_mgr"
require_relative "./conup/invocation_context"
require_relative "./conup/request_object"
require_relative "./conup/update_mgr"

module DEA
  class CollectServer
    # this is used for collect tx data from clients and collect data from other dea collect_servers
    class Echo < EM::Connection
      # def initialize#(instance_registry)
      # #@instance_registry = instance_registry
      # end
      def receive_data(data)
        #send_data(data)

        puts data

        # begin
        handle = data[2,data.length] # there are two unknown chars
        puts handle
        @json = JSON::parse(handle)
        instance_id =  @json["instance_id"]

        version="1.0"
        alg="consistency"
        freeConf="concurrent_version_for_freeness"
        implType="Java_POJO"
        deps = Set.new
        indeps = Set.new
        if instance_id != nil
          #stats = @json["stats"]
          logger.info "id=#{instance_id}"

          transaction_id = @json["transaction_id"]
          eventType = @json["event_type"]

          pasts = @json["PastComps"]
          futures = @json["FutureComps"]
          name = @json["name"]

          d = @json["deps"]
          d.each{|dd| deps << dd}

          ind = @json["indeps"]

          ind.each{|i| indeps << i}
          comp  = Dea::ComponentObject.instance(name,version,alg,freeConf,deps,indeps,implType)
          puts "comp = #{comp}"
          # we just set value for component

          puts "deps nil ? #{deps == nil}"
          puts "indeps nil ? #{deps == nil }"
          comp.staticDeps = deps
          comp.staticInDeps = indeps

          txMonitor = Dea::TxDepMonitor.instance(comp)
          txLifecycleMgr = Dea::CompLifecycleManager.instance(comp)
          puts "txLifecycleMgr nil? #{txLifecycleMgr == nil}"
          txMonitor.notify(eventType,transaction_id, futures,pasts)

          if eventType == Dea::TxEventType::FirstRequestService
            # notify other deas
            other_dea_port = @json["other_dea_port"]
            other_dea_ip = @json["other_dea_ip"]
            msg = {}
            msg["parentTx"]	= transaction_id
            msg["parentComponent"] = name
            msg["rootTx"] = transaction_id
            msg["rootComponent"] = 	name
            Dea::ClientOnce.new(other_dea_ip,other_dea_port,msg.to_json)

          # we need
          end
        # deps = Array.new #children#
        # deps << "AuthComponent"
        # deps << "DBComponent"

        # @instance_registry.lookup_instance(instance_id).stats = stats
        elsif @json["rootTx"] != nil
          puts "from other deas? or i need to notify other deas????"
          parentTx = @json["parentTx"]
          parentC = @json["parentComponent"]
          rootTx = @json["rootTx"]
          rootC = @json["rootComponent"]

          invocationContext = Dea::InvocationContext.new(rootTx,rootC,parentTx,parentC,"","","")
          # here we need Hello have already notify its dea , txStart???
          # it conflicts with ... we call txLifecycleMgr.createID when app first communicate with its dea
          comp = Dea::ComponentObject.instance(parentC,version,alg,freeConf,deps,indeps,implType)
          #怎么会用parentComponent来创建ComponentObject？
          txLifecycleMgr = Dea::TxLifecycleManager.instance(comp)
          txLifecycleMgr.notifyCache(invocationContext)
        # txLifecycleMgr.startRemoteSubTx(invocationContext)
        elsif @json["msgType"] != nil
          puts "from remote conf"
          request = Dea::RequestObject.new
          request.commType= @json["commType"]
          request.srcIdentifier= @json["srcIdentifier"]
          request.targetIdentifier= @json["targetIdentifier"]
          request.protocol= @json["protocol"]
          request.msgType=@json["msgType"]
          request.payload= @json["payload"]
          comp = Dea::ComponentObject.instance("",nil,nil,nil,nil,nil,nil)
          puts "collect_server : conf : #{comp.identifier}"
          updateMgr = Dea::UpdateManager.instance(comp)
          result = updateMgr.processMsg(request)
          
          # write back response
          # send_data(data)
          
        end
      #puts "check set is ok : #{@instance_registry.lookup_instance(instance_id).stats}"

      end
    end

    attr_reader :bootstrap
    attr_reader :config
    # attr_reader :sids

    def initialize(bootstrap, config)
      @bootstrap = bootstrap
      @config    = config
    # @sids      = {}
    # @client    = nil
    end

    def start
      EM.run do
      #puts "test"
        EM.start_server(config["collect_ip"], config["collect_port"],  Echo)#,bootstrap.instance_registry)

        puts "start finished #{config["collect_port"]}"
        logger.info "Connecting collect stats server on #{config["collect_port"]}"
      end

    end

  end
end
