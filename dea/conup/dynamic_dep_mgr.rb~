# coding: UTF-8
# conup-core
require "steno"
require "steno/core_ext"
require_relative "./dep_registry"
require_relative "./tx_lifecycle_mgr"
require_relative "./comp_lifecycle_mgr"
require_relative "./tx_context"
require_relative "./version_consistency"
require_relative "./comp_lifecycle_mgr"
module Dea
  class DynamicDepManager
    attr_accessor :algorithm # Algorithm
    attr_accessor :compLifecycleMgr
    attr_accessor :compObj #ComponentObject
    attr_accessor :inDepRegistry # DependenceRegistry
    attr_accessor :outDepRegistry # DependenceRegistry
    
    attr_accessor :scope #Scope
    
    attr_accessor :txLifecycleMgr
    
    
    def initialize(identifier) # we need a string here
      @inDepRegistry = Dea::DependenceRegistry.new
      @outDepRegistry = Dea::DependenceRegistry.new
      @compObj = Dea::ComponentObject.instance(identifier,nil,nil,nil,nil,nil,nil)
      @algorithm = Dea::VersionConsistency.new
	@compLifecycleMgr = Dea::CompLifecycleManager.instance(@compObj)
        @txLifecycleMgr = Dea::TxLifecycleManager.instance(identifier)
    end
    
    private_class_method :new
     
    
    @@ddm = nil
    
    def DynamicDepManager.instance(identifier)
      @@ddm = new(identifier) unless @@ddm
      @@ddm
    end
    
    def dependenceChanged(hostComp)
      if @compObj.isTargetComp
        # get UpdateManager and updateManager.checkFreeness
        
      end
    end
    
    def dynamicUpdateIsDone
      return algorithm.updateIsDone(@compObj.identifier, self)
    end
    
    def getRuntimeDeps
      return @outDepRegistry.dependences
    end
    
    def getRuntimeInDeps
      return @inDepRegistry.dependences
    end
    
    def getStaticDeps
      return @compObj.staticDeps
    end
    
    def getStaticInDeps
      return @compObj.staticInDeps
    end
    
    def getTxLifecycleMgr
      # return NodeManager...generate(TxLifecycleMgr)
      @txLifecycleMgr = Dea::TxLifecycleManager.instance(@compObj.identifier)
      
      return @txLifecycleMgr
    end
    
    
    def getTxs
      return @txLifecycleMgr.getTxs()
    end
    
    def initLocalSubTx(txContext) #TransactionContext
	puts "in ddm init sub #{@compLifecycleMgr == nil}"
      return @algorithm.initLocalSubTx(txContext, @compLifecycleMgr ,self)
    end
    
    def isBlockRequiredForFree(algorithmOldVersionRootTxs ,txContext,isUpdateReqRCVD ) # Set<String> , TransactionContext,bool
      return @algorithm.isBlockRequiredForFree(algorithmOldVersionRootTxs,txContext,isUpdateReqRCVD,self)
    end
    
    def isReadyForUpdate
      
      return @algorithm.readyForUpdate(@compObj.identifier, self)
    end
    
    def manageDependencePayload(payload) #String
      
      plResolver = DepPayloadResolver.new(payload)
      
      operation = plResolver.operation
      
      params = getParamFromPayload(plResolver)
      
      return @algorithm.manageDependence4(operation , params, self, @compLifecycleMgr)
    end
    # private method
    def manageDependence(txContext) #TransactionContext
      puts "in manageDepedence(txCtx) #{@compLifecycleMgr == nil }"
      @algorithm.manageDependence3(txContext, self, @compLifecycleMgr)
      return true
    end
    
# this method is called by TxDepMonitor.notify
    def manageTx(txContext) # TransactionContext 
      curTxID = txContext.currentTx
      #puts "in ManageTx:"
      #puts @txLifecycleMgr ==nil
      @txLifecycleMgr.updateTxContext(curTxID, txContext)
      
	puts "txLifecycleMgr #{@txLifecycleMgr.txRegistry}"
      return manageDependence(txContext)
    end
    
    def ondemandSetupIsDone
      
      inDep = ""
      @inDepRegistry.dependences.each{|dep|
           inDep += dep + ","
           
        }
      puts "inDep = #{inDep}"  
        
      outDep =""
      @outDepRegistry.dependences.each{|dep|
        outDep+= dep+ " ,"
        }  
      puts "outDep = #{outDep}"
      txs = getTxs()
      puts "ondemandSetupIsDone,Tx: #{txs}"  
      algorithm.initiate(@compObj.identifier , self)
      
    end
    
    def getParamFromPayload(depPayloadResolver ) #DepPayloadResolver
      
      params = {}# <String,String>
                                                                                                                                          
      params["srcComp"] = depPayloadResolver.getParamter(DepPayload::SRC_COMPONENT)
      params["targetComp"] = depPayloadResolver.getParameter(DepPayload::TARGET_COMPONENT)
      
      params["rootTx"] = depPayloadResolver.getParameter(DepPayload::ROOT_TX)
      
      params["parentTx"] = depPayloadResolver.getParameter(DepPayload::PARENT_TX)
      params["subTx"] = depPayloadResolver.getParameter(DepPayload::SUB_TX)
      
      return params
    end
    
    def notifySubTxStatus(subTxStatus, invocationCtx,componentLifecycleMgr, proxyRootTxId)
      #                    TxEventType , InvocationContext, ComponentLifecycleMgr, String
      
      return @algorithm.notifySubTxStatus(subTxStatus, invocationCtx, componentLifecycleMgr , self,proxyRootTxId)          
    end
    
  end
  
end
