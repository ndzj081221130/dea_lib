# coding: UTF-8
# conup-core
 require  "steno"
 require  "steno/core_ext"
 require_relative "./tx_context"
 require_relative "./tx_event_type"
 require_relative "./dynamic_dep_mgr"
 require_relative "./comp_lifecycle_mgr"
 require_relative "./comp_status"
 require_relative "./dep"
 require_relative "./dep_registry"
 require_relative "./consistency_payload_creator"
module Dea
  class VersionConsistency
    
    FUTURE_DEP="FUTURE_DEP"
    PAST_DEP="FUTURE_DEP"
    ALGORITHM_TYPE="CONSISTENCY_ALGORITHE"
    
    attr_accessor :isSetupDone #ConcurrentHashMap TODO <String ,boolean>
    
    def manageDependence3(txContext, depMgr, compLifecycleMgr)
      puts "alg manageDependence3(),#{compLifecycleMgr == nil}"
      compStatus = compLifecycleMgr.compStatus #CompStatus
      
      txDepRegistry = TxDepMonitor.instance(compLifecycleMgr.compObj).txDepRegistry
      
      case compStatus
      when CompStatus::NORMAL
        doNormal(txContext,depMgr,compLifecycleMgr, txDepRegistry)
      when CompStatus::VALID
        doValid(txContext, depMgr, txDepRegistry)
      when CompStatus::ONDEMAND
        doOndemand(txContext,compLifecycleMgr , depMgr, txDepRegistry)
      when CompStatus::UPDATING
        doValid(txContext,depMgr,txDepRegistry)
      when CompStatus::FREE
        doValid(txContext, depMgr,txDepRegistry)
      else
        puts "comStatus: #{compStatus}"
       end 
    end
    
    def manageDependence4(operationType, params, depMgr, compLifecycleMgr)
                        #DepOperationType , Map<String,String>
        if compLifecycleMgr.compStatus == CompStatus::NORMAL
          return true
        end      
        
        manageDefResult = false;
        
        scrComp = params["srcComp"]
        targetComp = params["targetComp"]
        rootTx = params["rootTx"]
        
        case oprationType
        when DepOperationType::NOTIFY_FUTURE_CREATE
          puts "doNotifyFutureCreate"
          manageDepResult = doNotifyFutureCreate(srcComp,targetComp,rootTx,depMgr)
        when DepOperationType::NOTIFY_FUTURE_REMOVE
          puts "doNotifyFutureRemove"
          manageDepResult = doNotifyFutureRemove(srcComp,targetComp,rootTx,depMgr)
        when DepOperationType::NOTIFY_START_REMOVE_SUB_TX
          puts "deprecated!"
        when DepOperationType::ACK_SUBTX_INIT
          puts "before process ACK_SUBTX_INIT"
          parentID = params["parentTx"]
          subTxID = params["subTx"]
          manageDepResult = doAckSubTxInit(srcComp,targetComp,rootTx,parentTxID,
                                             subTxID,compLifecycleMgr,depMgr)
        when DepOperationType::NOTIFY_PAST_CREATE
          puts "before process NOTIFY_PASTS_CREATE"
          manageDepResult = doNotifyPastCreate(scrComp,targetComp,rootTx,depMgr)
          puts "after process NOTIFY_PAST_CREATE"
          
        when DepOperationType::NOTIFY_PAST_REMOVE
            puts "notify_past_remove"
            manageDepResult = doNotifyPastRemove(srcComp,targetComp,depMgr)
        when DepOperationType::NOTIFY_REMOTE_UPDATE_DONE
            puts "notify_remove_update_done"
            manageDepResult = doNotifyRemoteUpdateDone(srcComp,targetComp,depMgr)    
        else
           puts "case else"      
        end 
    end
    
    def doNormal(txCtx,depMgr,compLifecycleMgr,txDepRegistry)
       # TransactionContext
       
       if txCtx.eventType == TxEventType::TransactionEnd
          hostComp = txCtx.hostComponent
          ondemandSyncMonitor = compLifecycleMgr.compObj.ondemandSyncMonitor
          #TODO do we need sync here , cause we only have one DEA,one Component,one Mgr
          ondemandSyncMonitor.synchronize do 
            rootTx = txCtx.getProxyRootTxId(depMgr.scope)
            if compLifecycleMgr.compStatus == CompStatus::NORMAL
              size = depMgr.getTxs().size
              puts "depMgr.getTxs().size=#{size}"
              
              depMgr.getTxs().delete(txCtx.currentTx)
              depMgr.txLifecycleMgr.rootTxEnd(hostComp, rootTx) 
              
              puts "remove tx from TxRegistry and TxDepMonitor , local tx = "
              puts txCtx.currentTx
              puts "rootTx: #{rootTx}"
              
              return; 
            else
              if compLifecycleMgr.compStatus == CompStatus::ONDEMAND
                puts "ondemandSyncMonitor.wait()"
                #TODO here we call ondemandSyncMonitor.wait()
              end
            end
            
          end
          
          doValid(txCtx,depMgr,txDepRegistry)
          
       end
    end
    
    def doValid(txContext,depMgr, txDepRegistry)
      # TransactionContext
      txEventType = txContext.eventType #String
      
      scope = depMgr.scope
      
      rootTx = txContext.getProxyRootTxId(scope)
      
      if(rootTx == nil)
        puts "InvocationSequence"
        puts txContext.invocationSequence
        
        puts "hostComp:"
        puts txContext.hostComponent
        puts "real root: "
        puts txContext.rootTx
        
      end
      
      currentTx = txContext.currentTx
      hostComp = txContext.hostComponent
      
      inDepRegistry = depMgr.inDepRegistry
      outDepRegistry = depMgr.outDepRegistry
      
      futureComponents = txDepRegistry.getLocalDep(currentTx).futureComponents
      
      if txEventType == TxEventType::TransactionStart
        lfe = Dependency.new(FUTURE_DEP,rootTx,hostComp, nil,nil)
        
        if !inDepRegistry.contain(lfe)
          inDepRegistry.addDependence(lfe)
          
        end
        
        if !outDepRegistry.contain(lfe)
          outDepRegistry.addDependence(lfe)
        end
        
        Dependency lpe = Dependency.new(PAST_DEP,rootTx,hostComp,nil,nil)
        
        if  !inDepRegistry.contain(lpe)# local past edge
          inDepRegistry.addDependence(lpe)
          
        end
        
        if !outDepRegistry.contain(lpe)
          outDepRegistry.addDependence(lpe)
        end
        
        if rootTx == currentTx
          #current Tx is root
          isSetupDone[rootTx]=false
        else
          # ACK_SUBTX_INIT
          payload = ConsistencyPayloadCreator.createPayload6(hostComp,
                             txContext.parentComponent,rootTx,DepOperationType::ACK_SUBTX_INIT,
                             txContext.parentTx,txContext.currentTx)
                             
          #TODO DepNotifyService.synPost()
          # notify gorouter????
          
                             
        end
      elsif exEventType == TxEventType::DependencyChanged
        futureDepsInODR = outDepRegistry.getDependencesViaType(FUTURE_DEP)
        futureDepSameRoot = Array.new # concurrentSkipListSet<Dependence>
        
        futureDepsInODR.each{|dep|
          if dep.rootTx == rootTx
            futureDepSameRoot << dep
          end
          
          }  
          
          hasFutureInDep = false
          
          futureDepsInIDR = inDepRegistry.getDependencesViaType(FUTURE_DEP)
          futureDepsInIDR.each{|dep|
            
           if dep.rootTx == rootTx
              hasFutureInDep = true     
              break                                                                                                
            end
            }
           
           # during tx running , find some components will never be used anymore
           # if current component do not have any other future in deps , 
           # delete  the future deps from current to sub components 
            
            futureDepSameRoot.each{|dep|
              if !hasFutureInDeps && !futureComponents.contain(dep.targetCompObjIdentifier) && !dep.targetCompObjIdentifier == hostComponent
                  outDepRegistry.removeDependence(dep.type , dep.rootTx,dep.srcCompObjIdentifier ,dep.targetCompObjIdentifier )    
                  
                  payload = ConsistencyPayloadCreator.createPayload4(hostComp,dep.targetCompObjIdentifier,rootTx,DepOperationType::NOTIFY_FUTURE_REMOVE)
                  
                  puts "payload!!!"
                  ##TODO here notify gorouter?
                  
                  # DepNotifyService.depNotifyService = new DepNotifyService
                  # depNotifyService.syncPost(hostComp,dep.targetCompObjIdentifier,"Consistency","Denpendency_msg",payload)     
              end
                
              }
              
      elsif txEventType == TxEventType::TransactionEnd
            # if current Tx is not root , need to notify parent sub_tx_end
            
            if   currentTx != rootTx
              puts "current Tx is not root , do nothing?"
            else
              # current tx is root tx
              inDepRegistry.removeDependence(FUTURE_DEP,rootTx,hostComp , hostComp)
              inDepRegistry.removeDependence(PAST_DEP,rootTx,hostComp,hostComp)
              
              outDepRegistry.removeDependence(FUTURE_DEP,rootTx,hostComp,hostComp)
              outDepRegistry.removeDependece(PAST_DEP,rootTx,hostComp,hostComp)
              
              removeAllEdges(hostComp,rootTx,depMgr)
              
              puts "rootTx End #{hostComp} , rootTx = #{rootTx}" 
              
              isSetupDone.delete currentTx
            end
            
            depMgr.getTxs().delete currentTx
            
      else
         # up receiving FirstRequeceService
         # if current tx is root tx , we need to start set up
           # targetRef = {}# Set
            targetRef = []
            if scope != nil 
              targetRef = Array.new(scope.subComponents[hostComp])
              
            else
              targetRef = Array.new(depMgr.getStaticDeps())
              
            end
            
            if rootTx == currentTx && ( isSetupDone[rooTx] == nil && isSetupDone[rootTx] ==false)
                 fDeps = txDepRegistry.getLocalDep(currentTx).futureComponents #Array
                 
                 fDeps.each{|targetComp|
                     if !targetRef.include?(targetComp)
                       next
                     end
                     
                     dep = Dependency.new(FUTURE_DEP,currentTx,hostComp,targetComp,nil,nil)
                     
                     outDepRegistry.addDependence(dep)
                     
                     payload = ConsistencyPayloadCreator.createPayload4(hostComp,targetComp,currentTx,DepOperationType::NOTIFY_FUTURE_CREATE)
                     puts payload
                     #TODO
                     #Notify
          
                 }
                 
                 isSetupDone[rooTx] = true
            end
                 
      end
    end
    
    
    def doOndemand(txContext,compLifecycleMgr,depMgr,txDepRegistry)
      puts "doOndemand!!!"
      ondemandSyncMonitor = compLifecycleMgr.compObj.ondemandSyncMonitor
      
      ondemandSyncMonitor.synchronize do 
          if compLifecycleMgr.compStatus == CompStatus::ONDEMAND
            #TODO
            #ondemandSyncMonitor.wait()???
            puts "--------------ondemandSyncMonitor.wait()"
          end
      end
      
      doValid(txContext,depMgr,txDepRegistry)
    end
    
    
    def doNotifyFutureCreate(srcComp,targetComp,rootTx,depMgr)
      puts "#{scrComp} ---> #{targetComp} rootTX: #{rootTx}"
      
      inDepRegistry = depMgr.inDepRegitry
      outDepRegistry = depMgr.outDepRegistry
      
      dep = Dependence.new(FUTURE_DEP,rootTx,srcComp,targetComp,nil,nil)
      
      inDepRegistry.addDependence(dep)
      
      scope = depMgr.scope
      
      targetRef=[]
      if(scope != nil)
        targetRef = Array.new(scope.getSubComponents(targetComp))
      else
        targetRef = Array.new(depMgr.staticDeps)
      end
      
      
      targetRef.each{|str|
        
        futureDep = Dependence.new(FUTURE_DEP,rootTx,targetComp,str,nil,nil)
        
        outDepRegistry.addDependence(futureDep)
        
        payload = ConsistencyPayloadCreator.createPayload4(targetComp, str,rootTx,DepOperationType::NOTIFY_FUTURE_CREATE)
        
        #TODO notify !!!
        #depNotifyService.syncPost(targetComp, str, "ALGORITHM_TYPE","DEPENDENCY_MSG",payload)
        }
        
        return true
    end
    
    def doNotifyPastRemove(srcComp,targetComp,rootTx,depMgr)
      puts "#{scrComp} ---> #{targetComp} rootTx: #{rootTx}"
      
      inDepRegistry = depMgr.inDepRegistry
      
      inDepRegistry.removeDependence(PAST_DEP,rootTx,srcComp,targetComp)
      
      return removeAllEdges(targetComp,rootTx,depMgr)
      
    end
    
    def doNotifyPastCreate(scrComp,targetComp,rootTx,depMgr)
      puts "#{srcComp} ---> #{targetComp} rootTx #{rootTx}"
      
      inDepRegistry = depMgr.inDepRegistry
      
      dep = Depedence.new(PAST_DEP,rootTx,srcComp,targetComp,nil,nil)
      
      inDepRegistry.addDependence(dep)
      
      txs = depMgr.getTxs() # Map<String , TxContext>
      
      flag = false
      
      txs.each{|key, tc|
        
        if tc.getProxyRootTxId == rootTx && tc.eventType!=TxEventType::TransactionEnd && !tc.fakeTx
          flag = true
          break
        end
        
        }
        
        outDepRegistry = depMgr.outDepRegistry
        
        if !flag
              inDepRegistry.removeDependence(FUTURE_DEP,rootTx,targetComp , targetComp)
              inDepRegistry.removeDependence(PAST_DEP,rootTx,targetComp,targetComp)
              
              outDepRegistry.removeDependence(FUTURE_DEP,rootTx,targetComp,targetComp)
              outDepRegistry.removeDependece(PAST_DEP,rootTx,targetComp,targetComp)
        end
        
        depMgr.dependenceChanged(targetComp)
        
        hostComp = depMgr.compObj.identifier
        
        txDepRegistry = TxDepMonitor.instance(hostComp).txDepRegistry
        
        removeFutureEdges4(targetComp,rootTx,depMgr,txDepRegistry)
        
        return true
    end
    
    
    def doNotifySubTxEnd(srcComp,targetComp,rootTx,parentTx,subTx,compLifecycleMgr,depMgr)
      
      puts "#{srcComp} ---> #{targetComp} subTx: #{subTx} rootTx: #{rootTx}"
      
      ondemandMonitor = compLifecycleMgr.compObj.ondemandSyncMonitor
      
      ondemandMonitor.synchronize do 
        
        allTxs = depMgr.getTxs()#Map<String,TxContext>
        
        txCtx = allTxs[parentTx]
        
        subTxHostComps = txCtx.subTxHostComps
        subTxStatuses = txCtx.subTxStatuses
        
        if compLifecycleMgr.compStatus == CompStatus::NORMAL
          return true
        end
        
        scope = depMgr.scope
        
        if scope != nil && !scope.subComponents[targetComp].includes?(srcComp) # scope.subComponents[targetComp] = Array
          
          return true
          
        end
        
        outDepRegistry = depMgr.outDepRegistry
        
        dep =  Dependence.new(PAST_DEP,rootTx,targetComp,srcComp,nil,nil)
        
        outDepRegistry.addDependence(dep)
        payload = ConsistencyPayloadCreator.createPayload4(targetComp,srcComp,rootTx,DepOperationType::NOTIFY_PAST_CREATE)
        puts "payload : #{payload}"
        #TODO
        #depNotifyService.sycPost(targetComp, srcComp,"ALGORITHM_TYPE","DEPENDENCE_MSG" ,payload)
        return true
      end
    end
    
    # be notified that a sub tx being initiated
    def doAckSubTxInit(srcComp,targetComp,rootTx,parentTxID,subTxID,compLifecycleMgr,depMgr)
      
      puts "#{srcComp} --> #{targetComp} subTx: #{subTxID} rootTx: #{rootTx}"
      
      ondemandSyncMonitor = compLifecycleMgr.compObj.ondemandSyncMonitor
      #TODO need sync ??/??? 
      
      ondemandMonitor.synchronize do 
        
        allTxs = depMgr.getTxs() #Map<String,TxContext>
        
        txCtx = allTxs[parentTxID]
        subTxHostComps = txCtx.subTxHostComps # MAp<String,>
        subTxStatuses = txCtx.subTxStatuses #Map<String, >
        
        subTxHostComps[subTxID] = srcComp
        subTxStatuses[subTxID] = TxEventType::TransactionStart
        
        if compLifecycleMgr == CompStatus::NORMAL
          return true
        end
        
        return removeFutureEdges5(targetComp,rootTx,parentTxID,subTxID,depMgr)
        
        
        
      end
      
    end
    
    
    #receiver NotifyFutureRemove
    #try to remove src --> target future dep
    
    def doNotifyFutureRemove(srcComp,targetComp,rootTx,depMgr)
      puts "#{srcComp} --> #{targetComp} subTx: #{subTxID} rootTx: #{rootTx}"
      
      inDepRegistry = depMgr.inDepRegistry
      inDeRegistry.removeDependence(FUTURE_DEP, rootTx, srcComp, targetComp)
      
      hostComp = depMgr.comObj.identifier
      txDepRegistry = TxDepMonitor.instance(hostComp).txDepRegistry
      
      result = removeFutureEdges(targetComp,rootTx,depMgr,txDepRegistry)
      result 
    end
    
     def doNotifyRemoteUpdateDone(srcComp,hostComp,depMgr)
       puts "#{hostComp} received notfiyRemoteUpdateDone from #{srcComp}" 
       
       scope = depMgr.getScope
       parentComps = []
       if scope!=nil
         parentComps = scope.parentComponents[hostComp]
       else
         parentComps = depMgr.compObj.staticInDeps
         
       end
       
       parentComps.each{|comp|
         
         #TODO notify 
         payload = ConsistencyPayloadCreator.createRemoteUpDateIsDonePayload(hostComp,comp,DepOperationType::NOTIFY_REMOTE_UPDATE_DONE)
         
         # depNotifyService.asynPost(hostComp,comp, "Consistency","Dependence_msg",payload)
         }
         
         depMgr.getRuntimeDeps().clear
         depMgr.getRuntimeInDeps().clear
         
         depMgr.scope = nil
         
         #TODO updateManager.remoteDynamicUpdateIsDone
         
         return true
      end
    
    #try to remove future dep when receive ACK_SUB_INIT
      def removeFutureEdges5(currentComp,rootTx,currentTxID,subTxID,depMgr)
        
        outDepRegistry = depMgr.outDepRegistry
        inDepRegistry = depMgr.inDepRegistry
        
        outFutureDeps = outDepRegistry.getDependencesViaType(FUTURE_DEP)
        outFutureOneRoot = Array.new # HashSet<Dependence>
        
        outFutureDeps.each{|dep|
          if dep.rootTx == rootTx && dep.srcCompObjIdentifier != dep.targetCompObjIdentifier
            outFutureOneRoot << dep
          end
          
          }
          
        ifFutureFlag = false
        futureDeps = inDepRegistry.getDependencesViaType(FUTURE_DEP)
        
        futureDeps.each{|dep|
          
          if deo.rootTx == rootTx && dep.srcCompObjIdentifier!= dep.targetCompObjIdentifier
            inFutureFlag = true
            break
          end
          }   
       
        if !inFutureFlag
          txDepMonitor = TxDepMonitor.instance(currentComp)
          
          outFutureOneRoot.each{|dep|
            isLastUse = txDepMonitor.isLastUse(currentTxID, dep.targetCompObjIdentifier, currentComp)
            if isLaseUse
                payload = ConsistencyPayloadCreator.createPayload4(dep.srcCompObjIdentifier, dep.targetCompIdentifier, dep.rootTx,DepOperationType::NOTIFY_FUTURE_REMOVE)
                #TODO notify
                
                # synPost(dep.srcCompObjIdentifier, dep.targetCompObjIdentifier, "algorithm_type", "dependence_msg" , payload)
            end
            }
        return true    
        end   
      end
    
      #try to remove future dep when receive NOTIFY_PAST_CREATE
      
      # according to the condition to decide whether need to remove the future dep
      
      def removeFutureEdges4(currentComp,rootTx,depMgr,txDepRegistry)
        
        outDepRegistry = depMgr.outDepRegistry
        inDepRegistry = depMgr.inDepRegistry
        
        outFutureDeps = outDepRegistry.getDependencesViaType(FUTURE_DEP)
        outFutureOneRoot = Array.new # HashSet<Dependence>
        
        outFutureDeps.each{|dep|
          
          if dep.rootTx == rootTx && dep.srcCompObjIdentifier != dep.targetCompObjIdentifier
               outFutureOneRoot << dep
          end
          }
          
       isFutureFlag = false
       
       futureDeps = inDepRegistry.getDependencesViaType(FUTURE_DEP)
       
       futureDeps.each{|dep|
         if dep.rootTx == rootTx && dep.srcCompObjIdentifier != dep.targetCompObjIdentifier
           inFutureFlag = true
           break
         end
         }   
         
        willNotUseFlag = true
       
       outFutureOneRoot.each{|dep|
         
         if !inFutureFlag
           localTxs = depMgr.getTxs() #Map<String , TxContext>
           
           localTxs.each{|key,txCtx|
             
             if txCtx.isFake
               next
             end
             
             fDeps = txDepRegistry.getLocalDep(txCtx.currentTx).futureComponents #Set<String>
             
             fDeps.each{|fdep|
               
               if fep == dep.targetCompObjIdentifier && txCtx.getProxyRootTxId(depMgr.scope) == rootTx
                 willNotUseFlag = false
                 break
               end
               }
             
             if !willNotUseFlag
               break
             end
             
             }
             
             if willNotUseFlag
               scope = depMgr.scope
               
               if scope!=nil && !scope.subCompnents[dep.srcCompObjIdentifier].includes?(dep.targetCompObjIdentifier)
                 next
               end
               
               outDepRegistry.removeDependence(dep)
               payload = ConsistencyPayloadCreator.createPayload4(dep.srcCompObjIdentifier, dep.targetCompObjIdentifier, dep.rootTx,DepOperationType::NOTIFY_FUTURE_REMOVE)
               #TODO notify
               puts "payload #{payload}"#
               #syncPost(dep.srcCompObjIdentifier, dep.targetCompObjIdentifier , "algorithm_type" , "dependence_msg", payload)
             end
         end
         
         }
        
         return true
      end
      
      def removeAllEdges(hostComp,rootTx, depMgr)
        
        rtOutDeps = depMgr.getRuntimeDeps()
        
        rtOutDeps.each{|dep|
          
          if dep.rootTx == rootTx && dep.type == FUTURE_DEP && dep.srcCompObjIdentifier != dep.targetCompObjIdentifier
            
            payload = ConsistencyPayloadCreator.createPayload4(hsotComp,dep.targetCompObjIdentifier, rootTx,DepOperationType::NOTIFY_FUTURE_REMOVE)
              #TODO notify 
              #synPost(hostComp, dep.targetCompObjIdentifier, "consistency","dependency_msg",payload)
              
          elsif dep.rootTx == rootTx && dep.type == PAST_DEP && dep.srcCompObjIdentifier != dep.targetCompObjIdentifier
            payload = ConsistencyPayloadCreator.createPayload4(hsotComp,dep.targetCompObjIdentifier, rootTx,DepOperationType::NOTIFY_PAST_REMOVE)
              #TODO notify 
              #synPost(hostComp, dep.targetCompObjIdentifier, "consistency","dependency_msg",payload)
          end
          
          if dep.rootTx == rootTx
            rtOutDeps.delete(dep)
          end
          }
          
          rtInDeps = depMgr.getRuntimeInDeps()
          
          isPastDepExist = false
          
          rtInDeps.each{|dep|
            
            if dep.rootTx == rootTx
              isPastDepExist = true
              break
            end
            }
            
          #remove tx
          
          depMgr.getTxs().each{|key,txCtx| #Map<String , TxContext>
            
            if txCtx.getProxyRootTxId(depMgr.scope) == rootTx
              #//TODO have a bug>>>???
              
              if !isPastDepExist
                 depMgr.getTxs().each{|k,inCtx|
                   
                   if inCtx.getProxyRootTxId(depMgr.scope) == rootTx
                     puts "It is strang!!!"
                     #TODO tai qi pa l ...
                     depMgr.getTxs().delete(k)
                   end
                   }
              end
                
            end
            
            }  
            
            
          depMgr.getTxLifecycleMgr().rootTxEnd(hostComp,rootTx)
          
          return true  
      end
      
      
      def getDepsBelongToSameRootTx(rootTxID,allDeps) # String, Set<Dependence>
        
        result = [] #Set<Dependence>
        
        allDeps.each{|dep|
          
          if dep.rootTx == rootTxID
            result << dep
          end
          }
          
          result
      end
      
      def getAlgorithmType
        return "VersionConsistency"
      end
      
      def getOldVersionRootTxs(allInDeps) # Set<Dependence>
          oldRootTx =[] #Set<String>
          allInDeps.each{|dep|
            
               if dep.type == PAST_DEP
                 oldRootTx << dep.rootTx
               end
            }
          
          inDepsStr=""
          
          allInDeps.each{|dep|
            
            inDepsStr += "\n" + dep.to_s
            
           
            }
            
          puts "inDepsStr = #{inDepsStr}"  
          
          outDepsStr=""
          
          oldRootTx.each{|tx|
            outDepsStr += "\n" + tx
            
            }
            
          puts "oldRootTX = #{outDepsStr}"
          
          puts "in consistencey algorithm (allInDeps) #{allInDeps}"
          
          oldRootTx   
      end
      
      
      def readyForUpdate(compIdentifier,depMgr) #TODO to be test
        
        rtInDeps = depMgr.getRuntimeInDeps()
        
        # 
        allRootTxs = Array.new(rtInDeps)
        
        
         
         
        allRootTxs.each{|dep|
          
          puts "Algorithn inReady? #{dep}"
          }
          
          
        freeFlag = false
        allRootTxs.each{|tmpRoot|
          deps = getDepsBelongToSameRootTx(tmpRoot, rtInDeps)
          
          deps.each{|dep|
            pastFlag =false
            ftureFlag = false
            if dep.type ==    PAST_DEP
              pastFlag = true
            else
              futureFlag = true
            end
            }
            
            if pastFlag && futureFlag
              puts "deps: #{deps}"
              freeFlag = false
              break
            end
          
          }  
          
          freeFlag
      end
      
      
      
      def isBlockRequiredForFree(algorithmOldVersionRootTxs , txContext, isUpdateReqRCVD, depMgr) #Set<String>
        
        if !isUpdateReqRCVD
          return false
          
          
        end
        
        rootTx = txContext.getProxyRootTxId(depMgr.scope)
        
        if  algorithmOldVersionRootTxs != nil && algorithmOldVersionRootTxs.includes?(rootTx)
          
          realRootTxId = txContext.rootTx
          
          puts "real rootTxId : #{realRootTxId} proxyRootTxId: #{rootTx} not blocked ,\n algorithm : #{algorithmOldVersionRootTxs}"
          return false
        else
          puts "real rootTxId : #{realRootTxId} proxyRootTxId: #{rootTx} is blocked ,\n algorithm : #{algorithmOldVersionRootTxs}"
          return true
        end
      end
      
      
      
      def updateIsDone(hostComp,depMgr)
        
        isSetupDone.clear
        
        scope = depMgr.scope
        parentComps =[]
        
        if scope != nil
          parentComps = scope.parentComponents[hostComp]
        else
          parentComps = depMgr.compObj.staticInDeps
          
        end
        
        
        parentComps.each{|comp|
          
          payload = ConsistencyPayloadCreator.createRemoteUpDateIsDonePayload(hostComp,comp, DepOperationType::NOTIFY_REMOTE_UPDATE_DONE)
          
          #TODO notify
          #asynPost(hostComp , comp , "consistency" , "Dependency_msg" , payload)
          }
          
          depMgr.getRuntimeDeps().clear
          depMgr.getRuntimeInDeps().clear
          
          depMgr.scope = nil
          return true
      end
      
      
      def initiate(identifier, depMgr)
        
      end
      
      def initLocalSubTx(txContext,compLifecycleMgr,depMgr)
        
        hostComp = txContext.hostCompnent
        fakeSubTx = txContext.currentTx
        rootTx = txContext.rootTx
        parentTx = txContext.parentTx
        parentComp = txContext.parentComponent
        
        rtInDeps = depMgr.getRuntimeInDeps()
        rtOutDeps = depMgr.getRuntimeDeps()
        
        ondemandMonitor = compLifecycleMgr.compObj.ondemandSyncMonitor
        
        ondemandMonitor.synchronize do
          
          rootTx = txContext.getProxyRootTxId(depMgr.scope)
          
          if compLifecycleMgr.compStatus == CompStatus::ONDEMAND
            
            lfe = Dependence.new(FUTURE_DEP,rootTx,hostComp,hostComp,nil,nil)
            puts "lfe=#{lfe}"
            if !rtInDeps.includes?(lfe)
              rtInDeps << lfe
            end
            
            if !rtOutDeps.include?(lfe)
              rtOutDeps << lfe
            end
            
            lpe = Dependence.new(PAST_DEP,rootTx,hostComp,hostComp,nil,nil)
            puts "lpe=#{lpe}"
            if !rtInDeps.includes?(lpe)
              rtInDeps << lpe
            end
            
            if !rtOutDeps.include?(lpe)
              rtOutDeps << lpe
            end
            
            
            #ACK_SUBTX_INIT
            
            payload = ConsistencyPayloadCreator.createPayload6(hostComp,parentComp,rootTx,DepOperationType::ACK_SUBTX_INIT , parentTx,fakeSubTx)
            puts "payload = #{payload}"
            #TODO notify
            #synPost(hostComp, parentComp,"consistency", "dependency_msg" , payload)  
            
          end
        end
        
        return true
      end
      
      
      def notifySubTxStatus(subTxStatus, invocationCtx,compLifecycleMgr, depMgr,proxyRootTxId)
        
        parentTx = invocationCtx.parentTx
        subTx = invocationCtx.subTx
        subComp = invocationCtx.subComp
        rootTx = invocationCtx.rootTx
        curComp = invocationCtx.parentComp
        
        if subTxStatus == TxEventType::TransactionStart
          
          ondemandSyncMonitor = compLifecycleMgr.compObj.ondemandSyncMonitor
          
          ondemandSyncMonitor.synchronize do
            allTxs = depMgr.getTxs() # Map<String,TxContext>
            
            txCtx = allTxs[parentTx]
            
            subTxHostComps = txCtx.subTxHostComps # Map<String,String>
            subTxStatuses = txCtx.subTxStatuses
            
            subTxHostComps[subTx]=subComp
            subTxStatuses[subTx]=TxEventType::TransactionStart
          end
          
          return true
        elsif subTxStatus == TxEventType::TransactionEnd
          
          return doNotifySubTxEnd(subComp,curComp,proxyRootTxId,parentTx,subTx,compLifecycleMgr,depMgr)
        else
          puts "unexpected sub transaction status #{subTxStatus}"
          return false
        end
      end
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    
  end
end